<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
		<style type='text/css'>
			.inputField { width: 100px; float: left; }
			.inputLabel { width: 175px; float: left;}
			.someInput { width: 100%; height: 30px; }
			#mainBody {width: 100%-20px; margin-top: 15px; padding-left: 10px; padding-right: 10px;}
			h4 {width: 100%; border-bottom: 1px solid #bebebe; margin-bottom: 4px;}
			.pm {height: 12px; padding-right: 5px;}
			.pm:hover {cursor: pointer;}
		</style>
		<script type="text/javascript" src="sylvester.js"></script>
		<script type="text/javascript" src="glUtils.js"></script>
		
		<script id="shader-fs" type="x-shader/x-fragment">
		  #ifdef GL_ES
			precision highp float;
		  #endif
		  
		  varying vec4 vColor;

		  precision mediump float;

		  uniform float vpw; // Width, in pixels
		  uniform float vph; // Height, in pixels
		  
		  uniform vec2 offset; // e.g. [-0.023500000000000434 0.9794000000000017], currently the same as the x/y offset in the mvMatrix
		  uniform vec2 pitch;  // e.g. [50 50]



		  void main(void) {

			float lX = gl_FragCoord.x / vpw;
			float lY = gl_FragCoord.y / vph;
		  
			float scaleFactor = 10000.0;
		  
			float offX = (scaleFactor * offset[0]) + gl_FragCoord.x;
			float offY = (scaleFactor * offset[1]) + (1.0 - gl_FragCoord.y);
		  
			if (int(mod(offX, pitch[0])) == 0 ||
				int(mod(offY, pitch[1])) == 0) {
			  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
			} else {
			  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
			}

			gl_FragColor = vColor;


		  }
		</script>

		<script id="shader-vs" type="x-shader/x-vertex">
		  attribute vec3 aVertexPosition;
		  attribute vec4 aVertexColor;

		  uniform mat4 uMVMatrix;
		  uniform mat4 uPMatrix;

		  varying vec4 vColor;

		  void main(void) {

		    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			vColor = aVertexColor;

		  }
		</script>

		<script type="text/javascript" src="tutorial.js"></script>
		
		<script type='text/javascript'>
		
			document.onkeypress = keyClick;
		
			var coneRadius = 1000;
			var fragments = 100;
			

			var dataStack = new Array();
		
			var gl;
			var gl2d;



			function initGL(canvas) {
				try {
					gl = canvas.getContext("experimental-webgl");
					gl.viewportWidth = canvas.width;
					gl.viewportHeight = canvas.height;
				} catch(e) { }
				if (!gl) { alert("Could not"); }
			}
			
			
			var shaderProgram;
			function initShaders() {


				var fragmentShader = getShader(gl, "shader-fs");
				var vertexShader = getShader(gl, "shader-vs");

				shaderProgram = gl.createProgram();
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				gl.linkProgram(shaderProgram);

				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
					alert("Could not initialize shaders");
				}

				gl.useProgram(shaderProgram);

				shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
				gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

				shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
				gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

				shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
				shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
			}
			
			
			var points = [];
			var colorTable = new Array();
			
		  	var coneVertexPositionBuffer;
			var pointVertexPositionBuffer;
			
			function genCone() {
				coneVertexPositionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, coneVertexPositionBuffer);
				
				var degInc = 360.0/fragments;
				var height = coneRadius / Math.tan(45 * Math.PI / 180.0);

				var vertices = [];

				var curDeg = 0;
				for(var i = 0; i < fragments; i++) { 
					
					vertices = vertices.concat([0,0,0]);

					for(var j = 0; j < 2; j++){
						var x1 = coneRadius * Math.cos((curDeg + j*degInc) * Math.PI / 180.0);
						var y1 = coneRadius * Math.sin((curDeg + j*degInc) * Math.PI / 180.0);
						
						vertices = vertices.concat([x1,y1,-1.0 * height]);
					}
					curDeg += degInc;
				}
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				
				coneVertexPositionBuffer.itemSize = 3;
				coneVertexPositionBuffer.numItems = fragments * 3;
			}
			var pixelMult;
			function genPointCone() {
				pointVertexPositionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, pointVertexPositionBuffer);
				
				var degInc = 360.0/20;

				var vertices = [];

				var curDeg = 0;
				for(var i = 0; i < 20; i++) { 
					
					vertices = vertices.concat([0,0,0.1]);

					for(var j = 0; j < 2; j++){
						var x1 = 3 * Math.cos((curDeg + j*degInc) * Math.PI / 180.0);
						var y1 = 3 * Math.sin((curDeg + j*degInc) * Math.PI / 180.0);
						
						vertices = vertices.concat([x1,y1,0]);
					}
					curDeg += degInc;
				}
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				
				pointVertexPositionBuffer.itemSize = 3;
				pointVertexPositionBuffer.numItems = 20 * 3;
			}
			
			var pointVertexColorBuffer;

			
			function colorString(i1,i2,i3) {
				return Math.floor((i1*256))+"-"+Math.floor(i2*256)+"-"+Math.floor(i3*256);
			}
			
			function randColor(size, isQP) {
				var i1 = Math.random();
				var i2 = Math.random();
				var i3 = Math.random();
							
				var color = [];
				for(var i = 0; i < size; i++){
					if(isQP)
						color = color.concat([1.0, 1.0, 1.0, 0.2]);
					else
						color = color.concat([i1, i2, i3, 1.0]);
				}
				
				return color;
			}
			
			function getColorBuffer(color, size) {
				var tempVertexColorBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, tempVertexColorBuffer);
				
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(color), gl.STATIC_DRAW);
				tempVertexColorBuffer.itemSize = 4;
				tempVertexColorBuffer.numItems = size;
				return tempVertexColorBuffer;
			}
			
			function drawCircle2D(ctx, x, y, radius) {
			    ctx.beginPath();
			    ctx.arc(x, y, radius, 0, Math.PI*2, false);
			    ctx.closePath();
			    ctx.strokeStyle = "#000";
			    ctx.stroke();
				ctx.fillStyle = "#000";
				ctx.fill();
			}
			function drawLine2D(ctx,x1,y1,x2,y2) {
				ctx.moveTo(x1,y1);
				ctx.lineTo(x2,y2);
				ctx.strokeStyle = "#eee";
				ctx.stroke();
			}
			
			function Point() {
				var colorBuffer;
				var colorArray;
				var colorSize;
				var strColor;
				var x, y;
				var vx, vy;
				var qp;
				
				var angle;
				var vfunc;
			}
			
			function addCone(cx,cy, cb) {
				var c = new Point();
				if(!cb) cb = randColor(fragments*3);
				c.x = cx;
				c.y = cy;
				c.colorArray = cb;
				c.colorSize = fragments*3;
				c.strColor = colorString(cb[0], cb[1], cb[2]); //Math.floor(cb[0]*256) + "-" + Math.floor(cb[1]*256) + "-" + Math.floor(256*cb[2]);
				colorTable[c.strColor] = c;
				points = points.concat(c);
				$('data').value = getJSONstring();
				return c;
			}
			
			function drawCone(p) {
				
				if(p.x > ($('main-canvas').width + coneRadius) || p.x < (-1 * coneRadius) || p.y > ($('main-canvas').height + coneRadius) || p.y < (-1 * coneRadius)) {
					//cone will not influence anything and is just slow, dont plot it
					return;
				}
				
				loadIdentity();
				mvTranslate([p.x, p.y, 0.0]);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, coneVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, coneVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, getColorBuffer(p.colorArray,p.colorSize));
				gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);
				
				setMatrixUniforms();
				gl.drawArrays(gl.TRIANGLES, 0, coneVertexPositionBuffer.numItems);
				
				drawCircle2D(gl2d, p.x,p.y, 2.5);
				
				gl.disable(gl.BLEND);
				
			}
			
			function startScene() {
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				ortho(0, gl.viewportWidth, gl.viewportHeight, 0, -5, 5000);
			    loadIdentity();
			}
			
			var mouseIsDown = false;
			var curColor = null;
			
			function canvasClick(e) {
				pushStack();
				mouseIsDown = false;
				var p = getCursorPosition(e);
				addCone(p[0],p[1],curColor);
				curColor = null;
				redraw();
			}
			
			function getCursorPosition(e) {
				var x,y;
				if (e.pageX || e.pageY) {
					x = e.pageX;
					y = e.pageY;
			    } else {
					x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
					y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
			    }
				x -= document.getElementById("main-canvas").offsetLeft;
			    y -= document.getElementById("main-canvas").offsetTop;

				return [x,y]; 
			}
			
			function startDown(e) {
				mouseIsDown = true;
				curColor = randColor(fragments*3);
				canvasMouseMove(e);
			}
			function canvasMouseMove(e) {
				if(!mouseIsDown) return;
				
				var p = getCursorPosition(e);
				
				var c = new Point();
				c.x = p[0];
				c.y = p[1];
				c.colorArray = curColor;
				c.colorSize = fragments*3;
				c.qp = false;
				
				redraw(c);
			}
			
			function webGLStart() {
				var canvas = document.getElementById("main-canvas");
				canvas.addEventListener("mousedown", startDown, false);
				canvas.addEventListener("mousemove", canvasMouseMove, false);
				canvas.addEventListener("mouseup", canvasClick, false);
				initGL(canvas);
				
				canvas = document.getElementById("2d-canvas");
				canvas.addEventListener("mousedown", startDown, false);
				canvas.addEventListener("mousemove", canvasMouseMove, false);
				canvas.addEventListener("mouseup", canvasClick, false);
				
				var b_canvas = document.getElementById("2d-canvas");
				b_canvas.style.zIndex="100";
				gl2d = b_canvas.getContext("2d");
				
				initShaders();

				genCone();
				genPointCone();


				var size = 20*3;
				pointVertexColorBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, pointVertexColorBuffer);
				
				var color = [];
				for(var i = 0; i < size; i++)
					color = color.concat([0.0, 0.0, 0.0, 1.0]);
					
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(color), gl.STATIC_DRAW);
				pointVertexColorBuffer.itemSize = 4;
				pointVertexColorBuffer.numItems = size;

				redraw();
			  }

			function $(id) { return document.getElementById(id); }
			
			function reset() { 
				$('main-canvas').width = $('width').value;
				$('main-canvas').height = $('height').value;
				$('2d-canvas').width = $('width').value;
				$('2d-canvas').height = $('height').value;
				//fragments = $('frags').value;
				//coneRadius = $('cone-radius').value;
				//queryPoint = 0;
				// randomSpeed = $('random-speed').checked;
				pixelMult = 50;
				// moveSinusoidal = $('sinusoidal').checked;
				//userDefined = $('user-defined').checked;
				webGLStart();
			}
			
			function getJSONstring() {
				var data = {};
				var sites = [];
				var queries = [];
				for(var i = 0; i < points.length; i++) {
					var ar = [points[i].x, points[i].y];
					if(!points[i].qp) {
						sites = sites.concat(ar);
					} else {
						queries = queries.concat(ar);
					}
				}
				data['sites'] = sites;
				data['queries'] = queries;
				return JSON.stringify(data);
			}
			
			function takeNewData() {
				pushStack();
				var input = $('data').value;
				addNewData(input);
			}
			
			function addNewData(input) {
				var data = JSON.parse(input);
				var sites = data['sites'];
				var queries = data['queries'];
				points = [];
				for(var i = 0; i < sites.length; i += 2) {
					addCone(sites[i], sites[i+1]);
				}
				for(var i = 0; i < queries.length; i += 2) {
					addCone(queries[i], queries[i+1]);
				}
				redraw();
			}
			
			function pixelColor(arr,i,j, w,h) {
				if(i < 0 || j < 0 || i >= h || j >= w) return false;
				var i0 = arr[(i*w+j)];
				var i1 = arr[(i*w+j)+1];
				var i2 = arr[(i*w+j)+2];
				return i0 + "-" + i1 + "-" + i2;
			}
			
			var colorPairs;
			function triangulate() {
				var w = $('main-canvas').width;
				var h = $('main-canvas').height;
				var arr = gl.readPixels(0, 0, w, h, gl.RGB, gl.UNSIGNED_BYTE);
				if(!arr){
					arr = new WebGLUnsignedByteArray(w * h * 4);
					gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, arr);
				}
				
				colorPairs = new Array();
				// var test = 0;
				for(var i = 0; i < h; i++ ) {
					for(var j = 0; j < w; j++) {
						var c;
						if(i < 0 || j < 0 || i >= h || j >= w) {
							c = -1;
						} else {
							var i0 = arr[(i*w+j)];
							var i1 = arr[(i*w+j)+1];
							var i2 = arr[(i*w+j)+2];
 							c = i0 + "-" + i1 + "-" + i2;
						}

						for(var k = -1; k <=1; k += 2) {
							for(var l = -1; l <= 1; l+=2) {
								var c1;// = pixelColor(arr, i+k, j+l, w,h);
								if(i+k < 0 || j+l < 0 || i+k >= h || j+l >= w) {
									c1 = -1;
								} else {
									var j0 = arr[((i+k)*w+(j+l))];
									var j1 = arr[((i+k)*w+(j+l))+1];
									var j2 = arr[((i+k)*w+(j+l))+2];
		 							c1 = j0 + "-" + j1 + "-" + j2;
								}
								// document.title = c + ", " + c1;
								if(c1 != -1 && c != c1){//found a neighbor
									//document.title = "found a neighbor";
									if(!colorPairs[c]) colorPairs[c] = new Array();
									if(!colorPairs[c1]) colorPairs[c1] = new Array();
									colorPairs[c][c1] = true;
									colorPairs[c1][c] = true;
								}
							}
						}
						
					}
				}
				
				for(var i in colorPairs) {
					
					for(var j in colorPairs[i]) {
						for(var k in colorPairs[j]) {
							if(j == k) {
								var p1 = colorTable[j];
								var p2 = colorTable[k];
								drawLine2D(gl2d, p1.x,p1.y,p2.x,p2.y);
							}
						}
					}
					
				}
			}
			
			function redraw(p) {
				gl2d.clearRect(0,0,$('2d-canvas').width, $('2d-canvas').height);
				
				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.clearDepth(1.0);
				gl.enable(gl.DEPTH_TEST);
				gl.depthMask(true);
				gl.depthFunc(gl.LEQUAL);
				
				startScene();
				for(var i = 0; i < points.length; i++) {
					if(!points[i].qp) drawCone(points[i]);
				}
				
				if(p) {
					if(p.qp) gl.depthMask(false);
					drawCone(p);
				}
				gl.depthMask(false);
				for(var i = 0; i < points.length; i++) {
					if(points[i].qp) drawCone(points[i]);
				}
				// triangulate();
			}
			function pageStart() {
				$('width').value = $('main-canvas').width;
				$('height').value = $('main-canvas').height;
				$('data').value = '';
				webGLStart();
				
			}
			function plain() {

			}

			
			function getVFunc(coef) {
				return function(t) {
					var r = 0;
					for(var i = 0; i < coef.length; i++) {
						r += Math.pow(t,i) * coef[i];
					}
					return r;
				}
			}
			

			
			function getUserVFunc(rand) {
				return function(t) {
					return 0 //eval($('user-math').value);
				}
			}
			
			function getRand(min, max, integer) {
				var x = (Math.random() * (max-min)) + min;
				if(integer) 
					return Math.round(x);
				return x;
			}
			
			function pushStack() {
				dataStack.push(getJSONstring());
				if(dataStack.length > 0) $('btnUndo').disabled = false;
			}
			function undo() {
				var prev = dataStack.pop();
				addNewData(prev);
				$('data').value = prev;
				if(dataStack.length == 0) $('btnUndo').disabled = true;
			}
			
			var moveTime = 0;



			function move() {
				for(var i = 0; i < points.length; i++) {
					var vr = points[i].vfunc(moveTime);
					points[i].x += Math.cos(points[i].angle) * vr; //points[i].vx;
					points[i].y += Math.sin(points[i].angle) * vr; //points[i].vy;
				}
				$('data').value = getJSONstring();
				redraw();
				moveTime += 0.1;
				if(continueRandom) setTimeout("move();", 100);
			}
			function compress(id) {
				if($(id).style.display && $(id).style.display == 'none') $(id).style.display='';
				else $(id).style.display='none';
			}

			
			function keyClick(e) {
				var code;
				if (!e) var e = window.event;
				if (e.keyCode) code = e.keyCode;
				else if (e.which) code = e.which;
				if (code == 114) takeNewData();
			}

			
		</script>

		</script>
	</head>
	<body onload="pageStart();">

		<div id='mainBody'>
		<div style='float: right; width: 300px;'>
			<div style='padding-top: 0px; '>

			</div>
			<div style='padding-bottom: 15px;' id='settings'>
				<div class='someInput'>
					<span class='inputLabel'>Width:</span>
					<input type='text' class='inputField' id='width' value='900' onchange='reset();'/><br />
				</div>
				<div class='someInput'>
					<span class='inputLabel'>Height:</span>
					<input type='text' class='inputField' id='height' value='700' onchange='reset();' />
				</div>
				<div class='someInput'>

				</div>
				<div class='someInput'>

				</div>
				<div class='someInput'>

				</div>
				<!--<div sytle='height: 50px;'><input type='button' onclick='reset()' value='Update' /></div>-->
			</div>
			<div style='padding-bottom: 15px;' id='inputData' >
				<div style='height: 30px; padding-top:10px;'>
					<input type='text' id='data' style='width: 90%;' />
				</div>
				<div sytle='height: 50px;'><input type='button' onclick='takeNewData()' value='Reload data' /></div>
				<div sytle='height: 50px;'><input type='button' onclick='undo()' value='Undo Previous Change' id='btnUndo' disabled /></div>
			</div>

		</div>
		<div>
			<canvas id="2d-canvas" style="border: none; position: absolute;" width="900" height="675" ></canvas>
			<canvas id="main-canvas" style="border: none; position: absolute;" width="900" height="675" ></canvas>
		</div>
		</div>
	</body>
</html>
